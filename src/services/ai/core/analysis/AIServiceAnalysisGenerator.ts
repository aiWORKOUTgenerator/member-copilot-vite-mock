import { AIServiceComponent } from '../utils/AIServiceBase';
import { 
  UnifiedAIAnalysis, 
  CrossComponentConflict,
  GlobalAIContext 
} from '../types/AIServiceTypes';
import { PerWorkoutOptions } from '../../../../types';
import { dataTransformers } from '../../../../utils/dataTransformers';

/**
 * Handles core analysis generation logic
 * Extracted from AIService.ts to provide focused analysis generation
 */
export class AIServiceAnalysisGenerator extends AIServiceComponent {
  private domainServices: Map<string, any>;

  constructor(domainServices: Map<string, any>) {
    super('AIServiceAnalysisGenerator');
    this.domainServices = domainServices;
  }

  /**
   * Generate complete analysis using domain services
   */
  async generateAnalysis(
    currentSelections: PerWorkoutOptions,
    context: GlobalAIContext
  ): Promise<UnifiedAIAnalysis> {
    this.log('info', 'Starting analysis generation', {
      selections: Object.keys(currentSelections),
      contextAvailable: !!context
    });

    const analysisId = this.generateId();

    try {
      // Generate domain-specific insights in parallel
      const domainInsights = await this.generateDomainInsights(currentSelections, context);
      
      // Cross-component analysis
      const crossComponentConflicts = await this.generateCrossComponentConflicts(currentSelections, context);

      this.log('info', 'Analysis generation completed', {
        analysisId,
        insightCount: Object.values(domainInsights).flat().length,
        conflictCount: crossComponentConflicts.length
      });

      return {
        id: analysisId,
        timestamp: new Date(),
        insights: domainInsights,
        crossComponentConflicts,
        recommendations: [], // Will be populated by recommendation engine
        confidence: 0, // Will be calculated by recommendation engine
        reasoning: '', // Will be generated by recommendation engine
        performanceMetrics: {
          totalExecutionTime: 0, // Will be set by caller
          cacheHitRate: 0,
          memoryPeakUsage: 0
        }
      };

    } catch (error) {
      this.handleError(error as Error, 'generateAnalysis', { currentSelections, context });
      throw error;
    }
  }

  /**
   * Generate domain-specific insights in parallel
   */
  private async generateDomainInsights(
    selections: PerWorkoutOptions,
    context: GlobalAIContext
  ): Promise<UnifiedAIAnalysis['insights']> {
    this.log('debug', 'Generating domain insights', {
      domains: Array.from(this.domainServices.keys())
    });

    // Extract data for each domain service
    const energyData = selections.customization_energy;
    const sorenessData = dataTransformers.extractSorenessAreas(selections.customization_soreness);
    const focusData = dataTransformers.extractFocusValue(selections.customization_focus);
    const durationData = dataTransformers.extractDurationValue(selections.customization_duration);
    const equipmentData = dataTransformers.extractEquipmentList(selections.customization_equipment);

    // Generate insights in parallel for better performance
    const [energyInsights, sorenessInsights, focusInsights, durationInsights, equipmentInsights] = await Promise.all([
      this.executeDomainAnalysis('energy', energyData, context),
      this.executeDomainAnalysis('soreness', sorenessData, context),
      this.executeDomainAnalysis('focus', focusData, context),
      this.executeDomainAnalysis('duration', durationData, context),
      this.executeDomainAnalysis('equipment', equipmentData, context)
    ]);

    const insights = {
      energy: energyInsights,
      soreness: sorenessInsights,
      focus: focusInsights,
      duration: durationInsights,
      equipment: equipmentInsights
    };

    this.log('debug', 'Domain insights generated', {
      energy: energyInsights.length,
      soreness: sorenessInsights.length,
      focus: focusInsights.length,
      duration: durationInsights.length,
      equipment: equipmentInsights.length
    });

    return insights;
  }

  /**
   * Execute analysis for a specific domain
   */
  private async executeDomainAnalysis(
    domainName: string,
    data: any,
    context: GlobalAIContext
  ): Promise<any[]> {
    const service = this.domainServices.get(domainName);
    
    if (!service) {
      this.log('warn', `Domain service not found: ${domainName}`, { availableServices: Array.from(this.domainServices.keys()) });
      return [];
    }

    if (typeof service.analyze === 'function') {
      return await service.analyze(data, context);
    } else if (typeof service.generateInsights === 'function') {
      return await service.generateInsights(data, context);
    } else {
      this.log('warn', `Domain service ${domainName} has no analyze or generateInsights method`, { service });
      return [];
    }
  }

  /**
   * Generate cross-component conflicts
   */
  private async generateCrossComponentConflicts(
    selections: PerWorkoutOptions,
    context: GlobalAIContext
  ): Promise<CrossComponentConflict[]> {
    this.log('debug', 'Generating cross-component conflicts');

    const crossComponentService = this.domainServices.get('crossComponent');
    
    if (!crossComponentService) {
      this.log('warn', 'Cross-component service not found');
      return [];
    }

    if (typeof crossComponentService.detectConflicts === 'function') {
      return await crossComponentService.detectConflicts(selections, context);
    } else {
      this.log('warn', 'Cross-component service has no detectConflicts method');
      return [];
    }
  }

  /**
   * Validate analysis structure
   */
  validateAnalysis(analysis: UnifiedAIAnalysis): boolean {
    const requiredFields = ['id', 'timestamp', 'insights', 'crossComponentConflicts', 'recommendations', 'confidence', 'reasoning'];
    
    for (const field of requiredFields) {
      if (!(field in analysis)) {
        this.log('warn', `Invalid analysis: missing required field '${field}'`, { analysis });
        return false;
      }
    }

    // Validate insights structure
    const requiredInsightDomains = ['energy', 'soreness', 'focus', 'duration', 'equipment'];
    for (const domain of requiredInsightDomains) {
      if (!(domain in analysis.insights) || !Array.isArray(analysis.insights[domain as keyof typeof analysis.insights])) {
        this.log('warn', `Invalid analysis: missing or invalid insights for domain '${domain}'`, { analysis });
        return false;
      }
    }

    // Validate confidence is between 0 and 1
    if (analysis.confidence < 0 || analysis.confidence > 1) {
      this.log('warn', 'Invalid analysis: confidence must be between 0 and 1', { analysis });
      return false;
    }

    return true;
  }

  /**
   * Get analysis summary for debugging
   */
  getAnalysisSummary(analysis: UnifiedAIAnalysis): {
    id: string;
    timestamp: Date;
    insightCount: number;
    conflictCount: number;
    recommendationCount: number;
    confidence: number;
    domains: string[];
  } {
    const insightCount = Object.values(analysis.insights).flat().length;
    const domains = Object.keys(analysis.insights).filter(domain => 
      analysis.insights[domain as keyof typeof analysis.insights].length > 0
    );

    return {
      id: analysis.id,
      timestamp: analysis.timestamp,
      insightCount,
      conflictCount: analysis.crossComponentConflicts.length,
      recommendationCount: analysis.recommendations.length,
      confidence: analysis.confidence,
      domains
    };
  }

  /**
   * Check if analysis is recent (within specified time window)
   */
  isAnalysisRecent(analysis: UnifiedAIAnalysis, maxAgeMs: number = 5 * 60 * 1000): boolean {
    const age = Date.now() - analysis.timestamp.getTime();
    return age <= maxAgeMs;
  }

  /**
   * Get domain service health status
   */
  getDomainServiceHealth(): Record<string, 'healthy' | 'degraded' | 'unhealthy'> {
    const health: Record<string, 'healthy' | 'degraded' | 'unhealthy'> = {};

    for (const [domainName, service] of this.domainServices.entries()) {
      try {
        if (service && typeof service.getHealthStatus === 'function') {
          health[domainName] = service.getHealthStatus();
        } else if (service) {
          health[domainName] = 'healthy'; // Assume healthy if no health check method
        } else {
          health[domainName] = 'unhealthy';
        }
      } catch (error) {
        this.log('error', `Health check failed for domain ${domainName}`, { error });
        health[domainName] = 'unhealthy';
      }
    }

    return health;
  }

  /**
   * Update domain services (useful for testing or dynamic updates)
   */
  updateDomainServices(newServices: Map<string, any>): void {
    this.domainServices = newServices;
    this.log('info', 'Domain services updated', {
      newServiceCount: newServices.size,
      services: Array.from(newServices.keys())
    });
  }

  /**
   * Get list of available domain services
   */
  getAvailableDomains(): string[] {
    return Array.from(this.domainServices.keys());
  }

  /**
   * Check if a specific domain service is available
   */
  hasDomainService(domainName: string): boolean {
    return this.domainServices.has(domainName);
  }
} 