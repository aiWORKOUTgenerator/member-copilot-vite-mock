# FeatureBus API Reference

## ðŸ“‹ **Overview**

The `FeatureBus` is the central communication hub for inter-feature communication in the AI Service architecture. It provides event-driven architecture patterns, request-response communication, and feature discovery capabilities while maintaining loose coupling between features.

## ðŸŽ¯ **Class Definition**

```typescript
class FeatureBus {
  constructor()
  
  // Event System
  subscribe<T>(event: string, handler: EventHandler<T>, options?: SubscriptionOptions): string
  unsubscribe(event: string, handlerId?: string): void
  publish<T>(event: string, data: T, options?: PublishOptions): Promise<void>
  
  // Request-Response Communication
  request<TRequest, TResponse>(feature: string, operation: string, params: TRequest): Promise<TResponse>
  registerRequestHandler<TRequest, TResponse>(feature: string, operation: string, handler: RequestHandler<TRequest, TResponse>): void
  
  // Feature Management
  registerFeature(name: string, feature: FeatureCapabilities): void
  unregisterFeature(name: string): void
  getFeature(name: string): FeatureCapabilities | undefined
  listFeatures(): string[]
  
  // Health Monitoring
  checkFeatureHealth(featureName: string): Promise<FeatureHealthStatus>
  checkAllFeatureHealth(): Promise<Record<string, FeatureHealthStatus>>
  
  // Metrics and Monitoring
  getEventMetrics(): EventMetrics
  getRequestMetrics(): RequestMetrics
  getCommunicationHealth(): CommunicationHealthReport
}
```

## ðŸš€ **Event System**

### **subscribe<T>(event: string, handler: EventHandler<T>, options?: SubscriptionOptions): string**

Subscribes to events published by features with optional filtering and priority handling.

**Parameters:**
```typescript
interface SubscriptionOptions {
  feature?: string;           // Filter events from specific feature
  priority?: number;          // Handler execution priority (higher = earlier)
  filter?: (data: T) => boolean; // Custom event filtering
  once?: boolean;             // Auto-unsubscribe after first event
}

type EventHandler<T> = (data: T, metadata: EventMetadata) => void | Promise<void>;

interface EventMetadata {
  eventId: string;
  timestamp: Date;
  source: string;
  correlationId?: string;
}
```

**Returns:** Handler ID for unsubscribing

**Example: Basic Event Subscription**
```typescript
const featureBus = new FeatureBus();

// Subscribe to workout generation events
const handlerId = featureBus.subscribe('workout-generated', (workout, metadata) => {
  console.log(`New workout generated by ${metadata.source}:`, workout);
  // Update user's workout history
  updateWorkoutHistory(workout);
}, {
  feature: 'quick-workout-setup', // Only listen to events from this feature
  priority: 1 // High priority handler
});

// Unsubscribe when done
featureBus.unsubscribe('workout-generated', handlerId);
```

### **publish<T>(event: string, data: T, options?: PublishOptions): Promise<void>**

Publishes events to all subscribed handlers with optional correlation tracking.

**Parameters:**
```typescript
interface PublishOptions {
  source?: string;            // Event source identifier
  correlationId?: string;     // Request correlation ID
  delay?: number;             // Delay before publishing (ms)
  persistent?: boolean;       // Store event for late subscribers
}
```

**Example: Publishing Events**
```typescript
// Publish workout generation event
await featureBus.publish('workout-generated', {
  workoutId: 'workout-123',
  userId: 'user-456',
  workout: generatedWorkout,
  metadata: {
    duration: 30,
    focus: 'strength',
    generatedAt: new Date()
  }
}, {
  source: 'quick-workout-setup',
  correlationId: 'req-789'
});

// Publish user preference update
await featureBus.publish('user-preferences-updated', {
  userId: 'user-456',
  preferences: updatedPreferences,
  previousPreferences: oldPreferences
});
```

### **Event Patterns and Best Practices**

```typescript
// Pattern 1: Workflow Coordination Events
featureBus.subscribe('workout-requested', async (request) => {
  const analysis = await analyzeUserProfile(request.userId);
  await featureBus.publish('user-analysis-completed', {
    userId: request.userId,
    analysis,
    workoutRequestId: request.id
  });
});

// Pattern 2: Cross-Feature Data Sharing
featureBus.subscribe('workout-completed', async (workout) => {
  // Update recommendation engine with new workout data
  await featureBus.publish('recommendation-data-updated', {
    userId: workout.userId,
    workoutData: workout,
    updateType: 'workout-completion'
  });
});

// Pattern 3: Error Broadcasting
featureBus.subscribe('feature-error', (error) => {
  if (error.severity === 'critical') {
    // Trigger fallback mechanisms
    triggerFallbackProcedures(error.feature, error.operation);
  }
});
```

## ðŸ”„ **Request-Response Communication**

### **request<TRequest, TResponse>(feature: string, operation: string, params: TRequest): Promise<TResponse>**

Performs direct request-response communication with other features.

**Example: Inter-Feature Requests**
```typescript
// Request user analysis from another feature
const userAnalysis = await featureBus.request<
  { userId: string; includeHistory: boolean },
  UserAnalysisResult
>('user-preference-analysis', 'analyzeProfile', {
  userId: 'user-123',
  includeHistory: true
});

// Request equipment recommendations
const equipment = await featureBus.request<
  { workoutType: string; userLevel: string },
  EquipmentRecommendation[]
>('equipment-analyzer', 'recommendEquipment', {
  workoutType: 'strength',
  userLevel: 'intermediate'
});
```

### **registerRequestHandler<TRequest, TResponse>(feature: string, operation: string, handler: RequestHandler<TRequest, TResponse>): void**

Registers handlers for responding to requests from other features.

**Example: Request Handler Registration**
```typescript
// Register user analysis request handler
featureBus.registerRequestHandler<
  { userId: string; includeHistory: boolean },
  UserAnalysisResult
>('user-preference-analysis', 'analyzeProfile', async (params) => {
  const profile = await getUserProfile(params.userId);
  const history = params.includeHistory ? await getWorkoutHistory(params.userId) : null;
  
  return {
    preferences: profile.preferences,
    fitnessLevel: profile.fitnessLevel,
    goals: profile.goals,
    history: history,
    analyzedAt: new Date()
  };
});

// Register equipment analysis handler
featureBus.registerRequestHandler<
  { workoutType: string; userLevel: string },
  EquipmentRecommendation[]
>('equipment-analyzer', 'recommendEquipment', async (params) => {
  const recommendations = await analyzeEquipmentNeeds(params);
  return recommendations.map(rec => ({
    equipment: rec.name,
    priority: rec.priority,
    reason: rec.justification
  }));
});
```

## ðŸŽ¯ **Feature Management**

### **Feature Registration and Discovery**

```typescript
// Register a feature with its capabilities
featureBus.registerFeature('quick-workout-setup', {
  name: 'Quick Workout Setup',
  version: '1.0.0',
  capabilities: [
    'workout-generation',
    'duration-optimization',
    'equipment-integration'
  ],
  operations: [
    { name: 'generateWorkout', description: 'Generate a quick workout' },
    { name: 'optimizeDuration', description: 'Optimize workout duration' }
  ],
  events: [
    { name: 'workout-generated', description: 'Workout generation completed' },
    { name: 'duration-optimized', description: 'Duration optimization completed' }
  ],
  healthCheck: async () => {
    // Feature-specific health check logic
    return {
      healthy: true,
      details: { aiServiceConnected: true, cacheWorking: true }
    };
  }
});

// Discover available features
const features = featureBus.listFeatures();
console.log('Available features:', features);

// Get specific feature information
const quickWorkoutFeature = featureBus.getFeature('quick-workout-setup');
console.log('QuickWorkout capabilities:', quickWorkoutFeature?.capabilities);
```

## ðŸ“Š **Health Monitoring**

### **Feature Health Checks**

```typescript
// Check health of specific feature
const healthStatus = await featureBus.checkFeatureHealth('quick-workout-setup');
console.log('Feature health:', healthStatus);

// Expected response:
// {
//   healthy: true,
//   lastCheck: Date,
//   responseTime: 45, // ms
//   details: { aiServiceConnected: true, cacheWorking: true }
// }

// Check health of all features
const allHealth = await featureBus.checkAllFeatureHealth();
Object.entries(allHealth).forEach(([feature, health]) => {
  if (!health.healthy) {
    console.warn(`Feature ${feature} is unhealthy:`, health.details);
  }
});
```

### **Automated Health Monitoring**

```typescript
// Set up automated health monitoring
featureBus.subscribe('feature-health-check', async (healthReport) => {
  if (!healthReport.healthy) {
    // Trigger alerting
    await alertingService.sendAlert({
      type: 'feature-degradation',
      feature: healthReport.feature,
      details: healthReport.details,
      severity: healthReport.responseTime > 5000 ? 'critical' : 'warning'
    });
    
    // Attempt feature recovery
    await attemptFeatureRecovery(healthReport.feature);
  }
});
```

## ðŸ“ˆ **Metrics and Monitoring**

### **Event Metrics**

```typescript
// Get detailed event metrics
const eventMetrics = featureBus.getEventMetrics();

console.log('Event Metrics:');
console.log(`Total Events Published: ${eventMetrics.totalPublished}`);
console.log(`Active Subscriptions: ${eventMetrics.activeSubscriptions}`);
console.log(`Average Processing Time: ${eventMetrics.avgProcessingTime}ms`);

// Top events by volume
eventMetrics.eventsByVolume.forEach(event => {
  console.log(`${event.name}: ${event.count} events (${event.avgSize} avg size)`);
});
```

### **Request Metrics**

```typescript
// Get request-response metrics
const requestMetrics = featureBus.getRequestMetrics();

console.log('Request Metrics:');
console.log(`Total Requests: ${requestMetrics.totalRequests}`);
console.log(`Success Rate: ${requestMetrics.successRate}%`);
console.log(`Average Response Time: ${requestMetrics.avgResponseTime}ms`);

// Feature performance breakdown
requestMetrics.featureMetrics.forEach(feature => {
  console.log(`${feature.name}:`);
  console.log(`  Requests: ${feature.requestCount}`);
  console.log(`  Success Rate: ${feature.successRate}%`);
  console.log(`  Avg Response: ${feature.avgResponseTime}ms`);
});
```

## ðŸ”§ **Advanced Patterns**

### **Saga Pattern with Event Coordination**

```typescript
class WorkoutGenerationSaga {
  constructor(private featureBus: FeatureBus) {}
  
  async executeWorkoutGeneration(request: WorkoutRequest): Promise<WorkoutResult> {
    const sagaId = `saga-${Date.now()}`;
    
    try {
      // Step 1: User Analysis
      await featureBus.publish('saga-step-started', {
        sagaId,
        step: 'user-analysis',
        request
      });
      
      const userAnalysis = await featureBus.request(
        'user-preference-analysis',
        'analyzeProfile',
        { userId: request.userId }
      );
      
      // Step 2: Base Workout Generation
      await featureBus.publish('saga-step-completed', {
        sagaId,
        step: 'user-analysis',
        result: userAnalysis
      });
      
      const baseWorkout = await featureBus.request(
        'quick-workout-setup',
        'generateWorkout',
        { ...request, userAnalysis }
      );
      
      // Step 3: Enhancement
      const enhancedWorkout = await featureBus.request(
        'workout-enhancer',
        'enhanceWorkout',
        { baseWorkout, userAnalysis }
      );
      
      await featureBus.publish('saga-completed', {
        sagaId,
        result: enhancedWorkout
      });
      
      return enhancedWorkout;
      
    } catch (error) {
      await featureBus.publish('saga-failed', {
        sagaId,
        error: error.message
      });
      throw error;
    }
  }
}
```

### **Circuit Breaker Pattern**

```typescript
class FeatureCircuitBreaker {
  private failures = new Map<string, number>();
  private lastFailureTime = new Map<string, Date>();
  
  constructor(private featureBus: FeatureBus) {
    this.setupCircuitBreaker();
  }
  
  private setupCircuitBreaker() {
    // Wrap request method with circuit breaker
    const originalRequest = this.featureBus.request.bind(this.featureBus);
    
    this.featureBus.request = async <TRequest, TResponse>(
      feature: string,
      operation: string,
      params: TRequest
    ): Promise<TResponse> => {
      // Check circuit breaker state
      if (this.isCircuitOpen(feature)) {
        throw new Error(`Circuit breaker open for feature: ${feature}`);
      }
      
      try {
        const result = await originalRequest<TRequest, TResponse>(feature, operation, params);
        this.recordSuccess(feature);
        return result;
      } catch (error) {
        this.recordFailure(feature);
        throw error;
      }
    };
  }
  
  private isCircuitOpen(feature: string): boolean {
    const failures = this.failures.get(feature) || 0;
    const lastFailure = this.lastFailureTime.get(feature);
    
    if (failures >= 5) { // Circuit opens after 5 failures
      if (!lastFailure || Date.now() - lastFailure.getTime() < 60000) { // 1 minute timeout
        return true;
      }
    }
    
    return false;
  }
}
```

### **Event Sourcing Pattern**

```typescript
class EventSourcedWorkflowManager {
  private eventStore: EventStore = new EventStore();
  
  constructor(private featureBus: FeatureBus) {
    this.setupEventSourcing();
  }
  
  private setupEventSourcing() {
    // Store all events for replay capability
    featureBus.subscribe('*', async (data, metadata) => {
      await this.eventStore.append({
        eventId: metadata.eventId,
        eventType: metadata.eventType,
        data: data,
        timestamp: metadata.timestamp,
        source: metadata.source
      });
    });
  }
  
  async replayWorkflowFromEvents(workflowId: string): Promise<WorkflowState> {
    const events = await this.eventStore.getEventsForWorkflow(workflowId);
    
    let state: WorkflowState = { workflowId, steps: [], status: 'initializing' };
    
    for (const event of events) {
      state = this.applyEvent(state, event);
    }
    
    return state;
  }
}
```

## ðŸŽ¯ **TypeScript Integration**

Full TypeScript support with comprehensive type definitions:

```typescript
import {
  FeatureBus,
  EventHandler,
  RequestHandler,
  FeatureCapabilities,
  EventMetrics
} from '@/services/ai/external/shared/core/orchestration';

// Type-safe event handling
interface WorkoutGeneratedEvent {
  workoutId: string;
  userId: string;
  workout: GeneratedWorkout;
  metadata: WorkoutMetadata;
}

const handler: EventHandler<WorkoutGeneratedEvent> = (data, metadata) => {
  // Type-safe access to event data
  console.log(`Workout ${data.workoutId} generated for user ${data.userId}`);
};

featureBus.subscribe<WorkoutGeneratedEvent>('workout-generated', handler);

// Type-safe request-response
interface AnalysisRequest {
  userId: string;
  includeHistory: boolean;
}

interface AnalysisResponse {
  preferences: UserPreferences;
  fitnessLevel: string;
  goals: string[];
}

const analysis = await featureBus.request<AnalysisRequest, AnalysisResponse>(
  'user-preference-analysis',
  'analyzeProfile',
  { userId: 'user-123', includeHistory: true }
);
```

## ðŸ›¡ï¸ **Error Handling and Resilience**

### **Error Broadcasting and Handling**

```typescript
// Global error handler
featureBus.subscribe('feature-error', (error) => {
  logger.error('Feature error occurred:', {
    feature: error.feature,
    operation: error.operation,
    message: error.message,
    severity: error.severity
  });
  
  // Trigger appropriate responses based on error severity
  switch (error.severity) {
    case 'critical':
      // Trigger immediate fallback
      triggerEmergencyFallback(error.feature);
      break;
    case 'warning':
      // Log and monitor
      monitoringService.recordError(error);
      break;
  }
});

// Feature-specific error handling
featureBus.subscribe('quick-workout-setup-error', async (error) => {
  if (error.type === 'ai-service-unavailable') {
    // Switch to template-based generation
    await featureBus.publish('fallback-activated', {
      originalFeature: 'quick-workout-setup',
      fallbackFeature: 'template-workout-generator'
    });
  }
});
```

## ðŸ“ž **Support and Examples**

- **[Advanced Patterns](../../integration/advanced/feature-communication.md)** - Complex communication patterns
- **[Event Sourcing](../../integration/advanced/event-sourcing.md)** - Event sourcing implementation
- **[Circuit Breakers](../../integration/resilience/circuit-breakers.md)** - Resilience patterns
- **[Performance Tuning](../../production/performance/feature-bus.md)** - Optimization strategies

---

**The FeatureBus enables sophisticated inter-feature communication while maintaining loose coupling and high observability.** 